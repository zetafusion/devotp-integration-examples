{"version":3,"file":"user-verification-signature-decryptor.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as crypto from 'node:crypto';\n\nexport interface DecryptedPayload {\n  identifier: string;\n  createdAt: string;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  decryptedData?: DecryptedPayload;\n}\n\nexport class PayloadDecryptor {\n  private readonly clientKey: Buffer;\n\n  constructor(clientKey: string) {\n    this.clientKey = Buffer.from(clientKey, 'hex');\n  }\n\n  private decryptPayload(encryptedData: string): DecryptedPayload {\n    // Split the IV and encrypted data\n    const [ivHex, encryptedPayload] = encryptedData.split(':');\n\n    if (!ivHex || !encryptedPayload) {\n      throw new Error('Invalid encrypted data format');\n    }\n\n    // Convert IV back to Buffer\n    const iv = Buffer.from(ivHex, 'hex');\n\n    try {\n      // Create decipher\n      const decipher = crypto.createDecipheriv(\n        'aes-256-cbc',\n        this.clientKey,\n        iv\n      );\n\n      // Decrypt the payload\n      let decrypted = decipher.update(encryptedPayload, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n\n      // Parse the JSON string back to an object\n      return JSON.parse(decrypted);\n    } catch (error) {\n      throw new Error('Failed to decrypt payload: ' + (error as Error).message);\n    }\n  }\n\n  public async validateDecryption(\n    email: string,\n    signature: string\n  ): Promise<ValidationResult> {\n    try {\n      // Decrypt the signature\n      const decryptedData = this.decryptPayload(signature);\n\n      // Verify that the decrypted identifier matches the provided email\n      if (decryptedData.identifier !== email) {\n        console.warn('Email mismatch:', {\n          decryptedIdentifier: decryptedData.identifier,\n          providedEmail: email,\n        });\n        return { isValid: false };\n      }\n\n      return { isValid: true, decryptedData };\n    } catch (error) {\n      console.error('Validation error:', error);\n      return { isValid: false };\n    }\n  }\n}\n"],"names":["PayloadDecryptor","clientKey","this","Buffer","from","_proto","prototype","decryptPayload","encryptedData","_encryptedData$split","split","ivHex","encryptedPayload","Error","iv","decipher","crypto","decrypted","update","JSON","parse","error","message","validateDecryption","_validateDecryption","_asyncToGenerator","_regeneratorRuntime","mark","_callee","email","signature","decryptedData","wrap","_context","prev","next","identifier","console","warn","decryptedIdentifier","providedEmail","abrupt","isValid","t0","stop","_x","_x2","apply","arguments"],"mappings":"iyNAeE,SAAAA,EAAYC,GACVC,KAAKD,UAAYE,OAAOC,KAAKH,EAAW,OACzC,IAAAI,EAAAL,EAAAM,UAgC8B,OAhC9BD,EAEOE,eAAA,SAAeC,GAErB,IAAAC,EAAkCD,EAAcE,MAAM,KAA/CC,EAAKF,KAAEG,EAAgBH,KAE9B,IAAKE,IAAUC,EACb,MAAM,IAAIC,MAAM,iCAIlB,IAAMC,EAAKX,OAAOC,KAAKO,EAAO,OAE9B,IAEE,IAAMI,EAAWC,mBACf,cACAd,KAAKD,UACLa,GAIEG,EAAYF,EAASG,OAAON,EAAkB,MAAO,QAIzD,OAHAK,GAAaF,QAAe,QAGrBI,KAAKC,MAAMH,GAClB,MAAOI,GACP,MAAM,IAAIR,MAAM,8BAAiCQ,EAAgBC,WAEpEjB,EAEYkB,8BAAkB,IAAAC,EAAAC,EAAAC,IAAAC,MAAxB,SAAAC,EACLC,EACAC,GAAiB,IAAAC,EAAA,OAAAL,IAAAM,eAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAMf,GANeF,EAAAC,QAITH,EAAgB7B,KAAKK,eAAeuB,IAGxBM,aAAeP,GAAKI,EAAAE,OAAA,MAIjC,OAHHE,QAAQC,KAAK,kBAAmB,CAC9BC,oBAAqBR,EAAcK,WACnCI,cAAeX,IACdI,EAAAQ,gBACI,CAAEC,SAAS,IAAO,OAAA,OAAAT,EAAAQ,gBAGpB,CAAEC,SAAS,EAAMX,cAAAA,IAAe,OAEG,OAFHE,EAAAC,OAAAD,EAAAU,GAAAV,WAEvCI,QAAQhB,MAAM,oBAAmBY,EAAAU,IAASV,EAAAQ,gBACnC,CAAEC,SAAS,IAAO,QAAA,UAAA,OAAAT,EAAAW,UAAAhB,oBApBE,OAsB9B,SAtB8BiB,EAAAC,GAAA,OAAAtB,EAAAuB,WAAAC,eAAAhD"}