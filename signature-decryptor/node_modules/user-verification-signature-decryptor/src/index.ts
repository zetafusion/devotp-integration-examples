import * as crypto from 'node:crypto';

export interface DecryptedPayload {
  identifier: string;
  createdAt: string;
}

export interface ValidationResult {
  isValid: boolean;
  decryptedData?: DecryptedPayload;
}

export class PayloadDecryptor {
  private readonly clientKey: Buffer;

  constructor(clientKey: string) {
    this.clientKey = Buffer.from(clientKey, 'hex');
  }

  private decryptPayload(encryptedData: string): DecryptedPayload {
    // Split the IV and encrypted data
    const [ivHex, encryptedPayload] = encryptedData.split(':');

    if (!ivHex || !encryptedPayload) {
      throw new Error('Invalid encrypted data format');
    }

    // Convert IV back to Buffer
    const iv = Buffer.from(ivHex, 'hex');

    try {
      // Create decipher
      const decipher = crypto.createDecipheriv(
        'aes-256-cbc',
        this.clientKey,
        iv
      );

      // Decrypt the payload
      let decrypted = decipher.update(encryptedPayload, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      // Parse the JSON string back to an object
      return JSON.parse(decrypted);
    } catch (error) {
      throw new Error('Failed to decrypt payload: ' + (error as Error).message);
    }
  }

  public async validateDecryption(
    email: string,
    signature: string
  ): Promise<ValidationResult> {
    try {
      // Decrypt the signature
      const decryptedData = this.decryptPayload(signature);

      // Verify that the decrypted identifier matches the provided email
      if (decryptedData.identifier !== email) {
        console.warn('Email mismatch:', {
          decryptedIdentifier: decryptedData.identifier,
          providedEmail: email,
        });
        return { isValid: false };
      }

      return { isValid: true, decryptedData };
    } catch (error) {
      console.error('Validation error:', error);
      return { isValid: false };
    }
  }
}
